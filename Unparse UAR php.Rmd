---
title: "Get data from GZ and UAR and unite the rest:"
author: "Antonio Avila"
date: "06/02/2020"
output: 
  html_notebook:
    code_folding: show
    # keep_md: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r message=FALSE, warning=FALSE}
library(jsonlite)
library(tidyverse)
library(rvest)
library("rgdal") # ReadOGR
library(sf)
# setwd("~/A - Estudios/LSE - Applied Social Data Science/Project/PM2.5/Data Europe/")
```

## Get data from Urban Access Regulations (webpage)

1. Read the data:

```{r}
uar <- read_json(path = "data/Urb. Access Reg data mapapi.txt", 
                      simplifyVector = TRUE)[[1]]
# "Low Emission Zone in place since the 1st" (or similar, say the day of the beguinning.)
uar %>% head(2)
uar[4:7, 2]
# I could make a scraper that goes to every page and gets more information.

# From the "introtext" I colud also get some information about when it started:
uar$introtext[2] %>% cat()
```

Note: Look if I can scrape more info from the pages or descriptions.

Get the meanings of the colours:

https://urbanaccessregulations.eu/userhome/map#car

```{r}
uar <- uar %>%
  mutate(
    lez = ifelse(scheme_color == 1, TRUE, FALSE),
    urb_toll = ifelse(scheme_color == 2, TRUE, FALSE),
    other_reg = ifelse(scheme_color == 3, TRUE, FALSE),
    em_scheme = ifelse(scheme_color == 4, TRUE, FALSE),
    city_latitude = as.numeric(city_latitude),
    city_longitude = as.numeric(city_longitude),
    scheme_color = as.numeric(scheme_color)
  ) %>%
  mutate(scheme = case_when( 
         scheme_color == 1 ~ "lez",
         scheme_color == 2 ~ "urban toll",
         scheme_color == 3 ~ "other regulations",
         scheme_color == 4 ~ "pollution emergency") %>% as.factor())

uar %>% head()

uar %>% # All mesures are included
  filter(str_detect(uar$cityname, "Paris"))
# uar %>% dim() # Almost 700 legislations!
```


Read the scheme data

```{r}
# This gives me the lists of names and their Ids
allscheme <- read_json(path = "data/AllScheme.txt", 
                       simplifyVector = TRUE)[[1]]
allscheme %>% head()
```


```{r}
# write.csv(x = uar, file = "data/UAR_data/uar.csv")
# write.csv(x = allscheme, file = "data/UAR_data/id_name_pairs.csv")
```


## Get the data grom GreenZones.eu

```{r}
library(DBI)
con <- dbConnect(RSQLite::SQLite(), 
                 dbname = "data/Greenzonesapp/db_greenzones.db")

# Explore:
dbListTables(con)
dbListFields(con, "Land")
DBI::dbGetQuery(con, "SELECT * from Zonenvorwarnung") 
# Kraftstoff -> Fuel
# SondereigenschaftAusprägung "specifics" look at "SondereigenschaftAusprägungTranslation".
# This works with "ZoneAusnahmeMap"(Zone exception map)

# This gives which distictives can enter where:
DBI::dbGetQuery(con, "SELECT * from ZonePlaketteMap") %>% head()
DBI::dbGetQuery(con, "SELECT * from Plakette") # Details and name of distinctives


# Vehicles:
# Types of vehicles and their category
DBI::dbGetQuery(con, "SELECT * from Fahrzeugart") %>% head()
```


```{r}
zones <- DBI::dbGetQuery(con, "SELECT Zone.*, Land.TitelLocal 
                         from Zone
                         LEFT JOIN Land ON Zone.LandId = Land.Id")

# Figure out the translation for datetimes:
# (PROBABLY ADD A COUPLE MORE TO INCREASE ACCURACY? WORKS PERFECT NOW...)
dates <- c("20080101", "20150901", "20190502", "20170101")
dates <- as.integer(lubridate::ymd(dates))
numbers <- c(633347424, 635766624, 636923520, 636188256)
lm_dates <- lm(dates ~ numbers, model = TRUE)
lm_dates
plot(dates, numbers, type="b")

zones %>% head()

zones <- zones %>%
  mutate(
    InPlaceSince = lubridate::as_date(
      floor(InkraftSeit*lm_dates$coefficients[2])/1000000000 + lm_dates$coefficients[1]),
    lat = (MaxLatitude + MinLatitude)/2,
    lon = (MaxLongitude + MinLongitude)/2
    ) %>%
  select(-c("InkraftSeit"))

zones %>% head()

# I could get the translation (of countries) in English too

# Hey! If the min and max longitude is faily exact it is a very good proxi for the real shapefile (maybe a circle inside the sqare is a little better)

DBI::dbDisconnect(con)
```


This was quite nice, if I want to get the geografies and more data I should look at the dll files (for which I need a compiler from Hex).

## Objective now: 

Objective: 

1. Merge data from all sources with one Nuts3 region as an observation and with

(a) Which UAR have been applied in that zone, (DONE)
(b) from when? (DONE)
(c) any economical data from Eurostat. (DONE)
(d) Look at sources of air pollution (TO DO)
(e) Look at sources of congestion (TO DO)


### Know which zones are treated:

#### Use the coordinates to know which NUTS 3 regions are "treated" OR "not in the control" group

```{r}

# Source: https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/administrative-units-statistical-units/nuts
# (higher quality available)

# Read NUTS 1,2 and 3 zones from original file, filter to only nuts 2 ans 3 and correct it:
nuts.sf <- read_sf("data/NUTS3/ref-nuts-2016-01m") %>%
  select(-FID) %>%
  filter(LEVL_CODE %in% c(2, 3)) %>%
  st_make_valid()

Encoding(nuts.sf$NUTS_NAME) <- "UTF-8"

nuts.sf %>% as.data.frame() %>% head()
```

## Convert data from cities into geolocations:

#### From UAR:

```{r}
uar <- uar %>% arrange(scheme_color) # to improve the map

# (points)
uar_sf <- st_as_sf(uar, coords = c("city_longitude", "city_latitude"), 
                   crs = "+proj=longlat +datum=WGS84 +no_defs")

uar_sf %>% as.data.frame() %>% head()
```


**Restrict UAR to "Real" controls and not every kind of access regulations:**

(info from https://urbanaccessregulations.eu/userhome/map)

* Delete all access regulations in Poland (other access regulations are very week and LEZ in krakovia is implemented after 2018)
* delete all access regulations in 
  + Bucarest, Budapest, Sofía, Suceava, Salsburg
    - (very week, only to heavy trucks > 5 to 8 tones)
* delete all pollution emergency schemes (only 5-10 that do not coincide with a LEZ) (I am looking at average pollution)
* try to eliminate as much "late" LEZ:
  + Barcelona 
* try to eliminate as much "week" "other urban access regulations:
  + Dublin (only heavy vehicles),
  + Groningen (only 1 pedestrian street)
  + Würzburg (only heavy ~ >3.5T vehicles)
  
```{r}
uar_sf <- uar_sf %>%
  # Delete cities that I have reviewed the regulations are very week
  filter(!str_detect(cityname, "Budapest"),
         !str_detect(cityname, "Sofia"),
         !str_detect(cityname, "Bucharest"),
         !str_detect(cityname, "Suceava"),
         !str_detect(cityname, "Salzburg"),
         !str_detect(cityname, "Dublin"),
         !str_detect(cityname, "Groningen"),
         !str_detect(cityname, "Würzburg"),
         # Polish cities
         !str_detect(cityname, "Poznan"),
         !str_detect(cityname, "Wroclaw"),
         !str_detect(cityname, "Lodz"),
         !str_detect(cityname, "Gdynia"),
         !str_detect(cityname, "Warsawa"),
         # UK cities
         !str_detect(cityname, "Norwich"),#  (only an old castle)
         !str_detect(cityname, "Leicester"),#  LEZ (planned in 2026)
         !str_detect(cityname, "Manchester"),#  (planned by 2021)
         !str_detect(cityname, "Mersey River"),# Mersey River Crossings
         !str_detect(cityname, "Leeds"),#  (supposed 2020, now delayed)
         !str_detect(cityname, "Glasgow"),# ("came into effect" 31 december 2018, too late, and will be fully implemented in 2022)
         !str_detect(cityname, "Edinburgh"),#  (not yet applied)
         !str_detect(cityname, "Dundee"),#  (same)
         !str_detect(cityname, "Aberdeen"),#  (same) 
         !str_detect(cityname, "Nottingham"), # not really there 
         !str_detect(cityname, "Bath"), # in 2020
         !str_detect(cityname, "Brighton"), # only buses
         # Germany
         !str_detect(cityname, "Hamburg"), # only 2 streets in 2018
         # Denmark
         !str_detect(cityname, "Århus"), # from 2020
         ) %>%  
  # Delete pollution emergencies schemes
  filter(em_scheme == FALSE) %>%
  # Delete "late" LEZ 
  filter(!str_detect(cityname, "Barcelona"), # applied in 2020
         !str_detect(cityname, "Bordeaux"), # expected to be applied...
         !str_detect(cityname, "Birmingham",) # expected to be applied...
         )

## To check if names work
uar_sf %>% as.data.frame() %>%
  filter(str_detect(cityname, "Århus"))
uar_sf$scheme %>% table()
```

#### From GreenZones:

```{r}
gzones_sf <- st_as_sf(zones, coords = c("lon", "lat"), 
                   crs = "+proj=longlat +datum=WGS84 +no_defs")

gzones_sf$geometry[155] <- st_point(c(18.0280074, 59.3359563))
```


Clean gzones_sf of zones that are not really low emission zones and are week enough not to be considered as controls:

* Delete gygantic french zones that are only emergency access regulations:
  +  When high limits of PM10 are passed (>50microg and > 80microg) the organism responsible for the air can impose a ban on some cars in the limits it decides.
  + Looking at some examples (http://www.airpl.org/Air-exterieur/alertes-pollution) car restrictions have NOT been issued repeteadly (or at all) in the last years.
* Delete zones in place after 2018 (or 2019)?


```{r}
gzones_sf <- gzones_sf %>%
  # Delete cities that I have reviewed the regulations are very week
  ## French regions
  filter(!str_detect(Bild, "Atlantiques"),
         !str_detect(Bild, "Gers"),
         !str_detect(Bild, "Gironde"),
         !str_detect(Bild, "Vendee"),
         !str_detect(Bild, "Deux"),
         !str_detect(Bild, "Vienne"),
         !str_detect(Bild, "Herault"),
         !str_detect(Bild, "Maine"),
         !str_detect(Bild, "Creuse"),
         !str_detect(Bild, "Maine"),
         !str_detect(Bild, "Puy"),
         !str_detect(KML, "FrankreichLoireZPA"),
         !str_detect(KML, "Eure"),
         !str_detect(KML, "Loiret"),
         !str_detect(KML, "Cote"),
         !str_detect(KML, "Drome"),
         !str_detect(KML, "Isere"),
         !str_detect(KML, "Savoie"),# x2
         !str_detect(KML, "Rennes"),
         # UK
         !str_detect(KML, "Norwich"), 
         !str_detect(KML, "Nottingham"), 
         !str_detect(KML, "Brighton"), # only buses
         # New to add: 
         # Check those in Austria
         # !str_detect(KML, "Oberoesterreich"), # A highway
         ) %>%
  # Delete cities that have not already applied a LEZ
  filter(InPlaceSince <= as.Date("2018-01-01"), # Before 2018
         !str_detect(KML, "Valladolid"), # https://www.elnortedecastilla.es/valladolid/valladolid-disenara-zona-20200303071026-nt.html?ref=https:%2F%2Fwww.elnortedecastilla.es%2Fvalladolid%2Fvalladolid-disenara-zona-20200303071026-nt.html
         !str_detect(KML, "Valencia")
  )

# gzones_sf %>%
#   filter(str_detect(KML, "Brighton"))
```


```{r}
# (polygons)
# 1. Create a list of polygons with the latitudes and longitudes
zones <- gzones_sf %>% as.data.frame() %>% dplyr::select(-geometry)

zones_polygons <- apply(
  X = t(zones[c("MinLongitude", "MinLatitude",
                "MaxLongitude", "MaxLatitude")]),
  MARGIN = 2, 
  function(x){
    Polygon(matrix(c(x[1], x[2], # lower left
                     x[1], x[4], # lower right
                     x[3], x[4], # upper right
                     x[3], x[2], # upper left 
                     x[1], x[2]  # The beguinning again
    ), byrow = TRUE, ncol = 2), hole = FALSE)
  })
# 2. transform them into "spatial polygons" and create a SpatialDF:

# This is going for each polygon, transform it into a "Polygons".
p1 <- lapply(seq_along(zones_polygons), function(i){
  Polygons(list(zones_polygons[[i]]), ID = row.names(zones)[i])
})

sps = SpatialPolygons(p1, 
                      proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs"))

gzones_sp_pol <- SpatialPolygonsDataFrame(sps,
                                          data = zones)

gzones_sf_pol <- st_as_sf(gzones_sp_pol)

# { # Old static map
#   plot(uar_sp, col = "blue")
#   plot(NUTS3_16, add = TRUE)
#   plot(gzones_sp_pol, col = "red", add = TRUE)
# }

# New Leaflet map
library(leaflet)
library(htmlwidgets)

col_map <- c("red", "blue", "green")
col_size <- c(4,3,1,2)

policy_map <- leaflet() %>% 
  addTiles() %>% 
  addPolygons(data = nuts.sf,
              color = "black",
              weight = 1,
              # opacity = NA,
              fill = NA) %>%
  addPolygons(
    data = gzones_sf_pol,
    popup = paste0("<b> Name: </b>", gzones_sf_pol$KML,  
                   "<br/> <b> In place since: </b>", gzones_sf_pol$InPlaceSince, 
                   "<br/> <b> Country: </b>", gzones_sf_pol$TitelLocal,
                   "<br/> <b> Source: </b> GreenZonesApp")) %>%
  addCircleMarkers(
    data = uar_sf, weight = NA,
    opacity = 0.1,
    color = NA,
    fillColor = col_map[uar_sf$scheme_color],
    fillOpacity = 0.9,
    radius = col_size[uar_sf$scheme_color]*2,
    popup = paste0("<b>", uar_sf$cityname, "</b> <br/>",
                   "<b> Scheme: </b>", uar_sf$scheme, "<br/>",
                   "<b> Source: </b> U.A.R")
    ) %>% 
  setView(15, 50, zoom = 3)


# policy_map

# htmlwidgets::saveWidget(policy_map, file="policy_map.html")
```

#### From Umweltbundesamt

```{r}
db <- dbConnect(RSQLite::SQLite(), "data/capstonedb")
umweltzonen <- dbGetQuery(db, "SELECT * from umweltzonen")
dbDisconnect(db)

# Add year variables:
umweltzonen <- umweltzonen %>%
  mutate(
    year_stage1 = as_date(Stage_1, format = "%d.%m.%Y") %>% year(),
    year_stage2 = as_date(Stage_2, format = "%d.%m.%Y") %>% year(),
    year_stage3 = as_date(Stage_3, format = "%d.%m.%Y") %>% year(),
    date_announced = as_date(Announcment),
    year_announced = year(date_announced))


umweltzonen %>% head()
# umweltzonen %>% dim()
```

```{r}
# # Change names so they are searchable
# names_changed <- sub(" *\\ .*", "", umweltzonen$LEZ)
# names_changed <- sub(" *\\(.*", "", names_changed)

# Get coordinates of each name
temp <- list()
for (i in 1:length(umweltzonen$LEZ)){
  lala <- osmdata::getbb(umweltzonen$simple_LEZ[i])%>%
    apply(1, mean)
  temp[[i]] <- lala
}
temp2 <- lapply(temp, as.data.frame)
temp2 <- lapply(temp2, rownames_to_column, var = "latlong")
# temp2[[1]]
temp2 <- data.table::rbindlist(temp2, use.names = FALSE)
temp2$id <- rep(x = 1:58, 2) %>% sort()
temp2 <- temp2 %>% pivot_wider(names_from = "latlong",
                      values_from= "X[[i]]")

umweltzonen <- umweltzonen %>% cbind(temp2[, c("x", "y")])
umweltzonen <- st_as_sf(umweltzonen, coords = c("x", "y"),
                 crs = "+proj=longlat +datum=WGS84 +no_defs")
umweltzonen %>% names()
# umweltzonen
```

##### Look if some have been applied very recently:

```{r}
umweltzonen %>% as.data.frame() %>%
  arrange(desc(year_stage1)) %>%
  select(year_stage1) %>% table()
```

No, I should keep them all.

```{r}
# saveRDS(umweltzonen, "data/umweltbundesamt/umweltzonen.rds")
# umweltzonen <- readRDS("data/umweltbundesamt/umweltzonen.rds")
```

### Create multiple sets of controls: 

Idea: 1 Delete UAR that are inside a given Green Zones buffer zone, 2. Include as controls of a given city those hat have never implemented lez or those that have not yeat implemented them. if there is no info they are not included. This could increase the set of controls for "early" LEZ in germany.


Unite city-points/zones with the databases of characteristcs

```{r}

# nuts.sf <- nuts.sf %>% st_make_valid()
# uar_sf <- uar_sf %>% st_make_valid()
# gzones_sf <- gzones_sf %>% st_make_valid()
# gzones_sf_pol <- gzones_sf_pol %>% st_make_valid()

get_buffer_km <- function(data_points, km){
  data_points %>%
    st_transform(29902) %>% # Irish grid, that uses meters
    st_buffer(dist = units::set_units(km, "km")) %>% # How big is the perimeter
    st_transform(crs = "+proj=longlat +datum=WGS84")
}

buffer_80_uar <- get_buffer_km(uar_sf, 60)

# ! Note! I don't need to do a buffer of 50 and 100 km of small (city-center) urban access regulations.
# I could restrict to do this for sizable LEZ

# # Create a DB of centroids of NUTS regions
# nuts.sf_centroid <- nuts.sf %>% st_centroid()
# nuts.sf_centroid

nuts.sf <- nuts.sf %>%
  mutate(
    
    # Controls by UAR 
    with_uar_point = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, uar_sf)$NUTS_ID %>% 
           unique()),
      TRUE, FALSE),
    with_uar_30km = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, get_buffer_km(uar_sf, 30))$NUTS_ID %>%
           unique()),
      TRUE, FALSE),
    with_uar_60km = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf_centroid, get_buffer_km(uar_sf, 60))$NUTS_ID %>%
           unique()),
      TRUE, FALSE),
    
    # Controls by Green Zones app
    with_gzones_point = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, gzones_sf)$NUTS_ID %>% 
           unique()),
      TRUE, FALSE),
    with_gzones_30km = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf,  get_buffer_km(gzones_sf, 30))$NUTS_ID %>%
           unique()),
      TRUE, FALSE),
    with_gzones_60km = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, get_buffer_km(gzones_sf, 60))$NUTS_ID %>%
           unique()),
      TRUE, FALSE),
    
    # Controls by Umweltzonen Locations
    with_umweltzonen_point = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, umweltzonen)$NUTS_ID %>% 
           unique()), 
      TRUE, FALSE),
    with_umweltzonen_30km = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, get_buffer_km(umweltzonen, 30))$NUTS_ID %>%
           unique()), 
      TRUE, FALSE),
    with_umweltzonen_60km = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, get_buffer_km(umweltzonen, 60))$NUTS_ID %>%
           unique()),
      TRUE, FALSE)
  )

# + Include all cities mentioned in umweltbundesamt as non-controls

ggplot(nuts.sf %>%
         filter(with_uar_60km == TRUE)) +
  geom_sf(aes(color = as.factor(LEVL_CODE))) +
  geom_sf(data = buffer_60_uar) +
  geom_sf(data = umweltzonen)
  # geom_sf(data = nuts.sf_centroid, color = "red", size = 0.2)

# leaflet() %>% 
#   addTiles() %>%
#   addPolygons(data = nuts.sf %>%
#                 filter(with_uar_80km == FALSE),
#               weight = 4, col = "red") %>%
#   addPolygons(data = buffer_80_uar, col = "green") %>%
#   addCircleMarkers(data = nuts.sf_centroid, 
#              # clusterOptions = markerClusterOptions(),
#               popup = paste0(
#                 "<b>", nuts.sf_centroid$NUTS_ID, "</b> <br/>",
#                 "<b> Name: </b>", 
#                 nuts.sf_centroid$NUTS_NAME, "<br/>"))
```


### Get list of treated:

Those NUTS regions that are INSIDE a OMS LEZ 
+ 
those NUTS who are in the center of UAR (only LEZ)
+
Those NUTS who are in the center of g_zones
+
The geographical location of all cities named in Umweltbundesamt (Inagurated before XXX)
-
Restricted only to german cities (NUTS_ID starts by "DE")

```{r}
# import OMS LEZ geographies:
lez_shapes <- read_sf("data/lez_data2") %>%
  st_make_valid()

## This is to try to avoid very "small" parts of a NUTS region inside a LEZ make them bain ategorized as "Treated". I could do this case by case too.
# temp <- lez_shapes %>%
#   st_transform(29902) %>% # Irish grid, that uses meters
#   st_snap(nuts.sf, tolerance = units::set_units(2, "km")) %>%
#   st_transform(crs = "+proj=longlat +datum=WGS84") 

uar_sf_lez <- uar_sf %>% filter(lez == TRUE)

nuts.sf <- nuts.sf %>%
  mutate(
    treated_osm = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, lez_shapes)$NUTS_ID %>% 
           unique()),
      TRUE, FALSE),
    treated_uar = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, uar_sf_lez)$NUTS_ID %>% 
           unique()),
      TRUE, FALSE),
    treated_gz = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, gzones_sf)$NUTS_ID %>% 
           unique()),
      TRUE, FALSE),
    treated_uz = ifelse(
      NUTS_ID %in% 
        (st_intersection(
          nuts.sf, umweltzonen)$NUTS_ID %>% 
           unique()),
      TRUE, FALSE),
  ) %>% # That are inside Germany, if not they are NOT treated:
  mutate(
    treated_osm = ifelse(CNTR_CODE == "DE", treated_osm, FALSE),
    treated_uar = ifelse(CNTR_CODE == "DE", treated_uar, FALSE),
    treated_gz = ifelse(CNTR_CODE == "DE", treated_gz, FALSE),
    # treated_uz = ifelse(CNTR_CODE == "DE", treated_uz, FALSE)
  ) %>%
  mutate(
    treated_any = treated_osm | treated_uar | treated_gz | treated_uz
  )


# Treatment statuses mostly coincide
nuts.sf %>% as.data.frame() %>%
  select(treated_osm, treated_uar, treated_gz, treated_uz) %>%
  table()
```



<!-- ```{r} -->
<!-- # This keeps all the cities (regulations) and includes the LEZ zone in which they "intersect" (default) in and their characterisitics. -->

<!-- uar_points.sf_nuts <- st_join(uar_points.sf, uar_sf)  -->
<!-- gzones_sp.sf_nuts <- st_join(gzones_sp.sf, nuts.sf)  -->
<!-- gzones_sp_pol.sf_nuts <- st_join(gzones_sp_pol.sf, nuts.sf)  -->

<!-- # We can see the one with poligons has more rows -->
<!-- lapply(list(gzones_sp.sf_nuts, gzones_sp_pol.sf_nuts), dim) -->

<!-- # Look for Paris: -->
<!-- lapply(list(gzones_sp.sf_nuts, gzones_sp_pol.sf_nuts), function(x){ -->
<!--   as.data.frame(x) %>%  -->
<!--   filter(ElternzoneId == 22)  %>% -->
<!--   select(NUTS_NAME) %>% as.character() -->
<!-- }) # The zones df includes all NUTS regions in contact with the zone! -->

<!-- # Note: This looks like be easily changed from "intersect" to "covers" or "is_within_distance" -->


<!-- gzones_sp.sf_nuts %>% as.data.frame() %>%  -->
<!--   filter(ElternzoneId == 22) -->
<!-- ?st_join -->

<!-- # st_contains(points.sf, nuts.sf) -->

<!-- plot(uar_points.sf_nuts) -->
<!-- plot(gzones_sp.sf_nuts) -->
<!-- plot(nuts.sf$geometry) -->

<!-- # Convert back to Spatial* -->
<!-- uar_nuts <- as(uar_points.sf_nuts, "Spatial") -->
<!-- gz_nuts <- as(gzones_sp.sf_nuts, "Spatial") -->
<!-- # srdf_meuse <- as(srdf_meuse, "Spatial") -->


<!-- # Create a variable of minimum time for gzones (GZ): -->
<!-- # The time the FIRST measure was applied. -->
<!-- # Note: This is not perfect because it only includes the zone of the point and not every NUTS included in the LEZ. -->
<!-- min_time <- gzones_sp.sf_nuts %>% as.data.frame() %>% -->
<!--       dplyr::group_by(NUTS_ID) %>%  -->
<!--       dplyr::summarise(min_time = min(InPlaceSince)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- min_time -->
<!-- ``` -->

<!-- Temporal application of policies: When were LEZ applied? -->

<!-- ```{r, fig.height=12, fig.width= 9} -->
<!-- all_times <- expand.grid(NUTS_ID = min_time$NUTS_ID,  -->
<!--                    year = seq(2005, 2020), -->
<!--                    month = seq(01, 12),  -->
<!--                    # month = c("01", "02", "03", "04", "05", "06", -->
<!--                    #          "07", "08", "09", "10", "11", "12"),  -->
<!--                    stringsAsFactors = FALSE) -->
<!-- all_times -->

<!-- panel_application <- all_times %>% -->
<!--   left_join(min_time) %>% -->
<!--   mutate(date = as.POSIXct(paste0(year,"-", month, "-01" )), -->
<!--          status = ifelse(date < min_time, 0, 1), -->
<!--          country = substr(NUTS_ID, 1, 2)) %>% -->
<!--   arrange(status) %>% -->
<!--   # mutate(ordered_factor = fct_inorder(NUTS_ID)) %>% -->
<!--   select(NUTS_ID, date, status, year, month, country) -->
<!-- panel_application -->
<!-- ``` -->


<!-- ```{r, fig.height=12, fig.width= 9} -->
<!-- # png(filename = "UAR application Europe.png",  -->
<!-- #     width = 750, height = 1200, res = 100) -->
<!-- panelView::panelView(month ~ status, data = panel_application,  -->
<!--           index = c("NUTS_ID", "date"),  -->
<!--           by.timing = TRUE, -->
<!--           axis.lab.gap = c(23,0),  -->
<!--           # axis.lab = "time", -->
<!--           background = "white", -->
<!--           main = "", -->
<!--           xlab = "", ylab = "",) -->
<!--           #legend.labs = c("No LEZ applied", "Only red, yellow or green sticker",  -->
<!--                           # "Only yellow or green sticker", "Only green stiker"), -->
<!--           #color = c("grey90", "red1", "yellow1", "green4")) -->
<!-- # dev.off() -->
<!-- ``` -->


<!-- Map of LEZ zones affected: -->
<!-- NOTE: Need to add ALL ZONES of a city that are affected. (use the bbox of one data or get the shapefiles of each zone) -->

<!-- ```{r} -->
<!-- dta_uar <- uar_points.sf_nuts %>% as.data.frame() %>% -->
<!--   select(NUTS_ID, NUTS_NAME, scheme) -->

<!-- dta_gz <- gzones_sp.sf_nuts %>% as.data.frame() %>% -->
<!--   select(NUTS_ID, NUTS_NAME, InPlaceSince) -->


<!-- NUTS3_map <- NUTS3_16 -->
<!-- NUTS3_map@data <- NUTS3_16@data %>% -->
<!--   left_join(dta_uar) %>% -->
<!--   left_join(dta_gz) -->

<!-- library(tmap) -->
<!-- library(leaflet) -->
<!-- tm(temp, "scheme") -->
<!-- qtm_lez <- tmap::qtm(temp, fill = "scheme",  -->
<!--                      bbox = c(-10, 30, 50, 71),  -->
<!--                      borders = NULL) -->

<!-- ##  ESTO DA LOS LUGARES EQUIVOCADOS PERO ES UN BUEN INTENTO -->
<!-- # leaflet() %>% addTiles() %>% -->
<!-- #   addPolygons(data = NUTS3_map, -->
<!-- #               popup = paste0("Name: ", NUTS3_map$NUTS_NAME), -->
<!-- #               weight = 0.5, -->
<!-- #               fill = NUTS3_map$scheme) -->

<!-- qtm_lez -->
<!-- tmap::tmap_leaflet(qtm_lez) -->
<!-- ``` -->

## 2 or 3 control statuses

```{r}
nuts.sf <- nuts.sf %>%
  mutate(
    contr_restr_point = case_when(
      with_umweltzonen_point ~ FALSE,
      with_gzones_point ~ FALSE,
      with_uar_point ~ FALSE,
      TRUE ~ TRUE # if none of the past conditions, it's a control
    ),
    contr_restr_30km = case_when(
      with_umweltzonen_30km ~ FALSE,
      with_gzones_30km ~ FALSE,
      with_uar_30km ~ FALSE,
      TRUE ~ TRUE # if none of the past conditions, it's a control
    ),
    contr_restr_60km = case_when(
      with_umweltzonen_60km ~ FALSE,
      with_gzones_60km ~ FALSE,
      with_uar_60km ~ FALSE,
      TRUE ~ TRUE # if none of the past conditions, it's a control
    )
  )
nuts.sf %>% names()
```


### Get degree of urbanization

- Modified in ArcGis fron LAU regions to NUTS 3 by taking the mean of (1, 2, 3) being urban, sub urban and rural.

- Source https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/population-distribution-demography/degurba#degurba01

- year: 2014

```{r}
nuts_urban <- st_read("data/arcgis/nuts_mean_urban.shp")
nuts_urban$DGUBA_CODE %>% hist(breaks = 45)

nuts_urban <- nuts_urban %>%
  as.data.frame() %>% # Remove Spatial info
  mutate(DGUBA_CODE = ifelse(DGUBA_CODE > 3 | DGUBA_CODE == 0,
                             NA, DGUBA_CODE)) %>% # Drop NAs
  select(LEVL_CODE, NUTS_ID, CNTR_CODE, DGUBA_CODE) %>%
  arrange(NUTS_ID) %>%
  dplyr::rename(urb_index = DGUBA_CODE)

nuts_urban$urb_index %>% hist(breaks = 45)
nuts_urban$urb_index %>% summary()

# Include the variable into nuts.sf
nuts.sf <- nuts.sf %>%
  left_join(nuts_urban)

(nuts.sf %>% as.data.frame() %>% select(-geometry) %>%
  filter(treated_any == TRUE) %>%
  select(urb_index))$urb_index %>% summary()

# 3rd quartile of urbanization index for treated is 2.548

```

Include all relevant data in nuts.sf and save it.


```{r}
# # Mark NUTS 3 regions that have a city or point marked in eather UAR or GZ
# nuts.sf <- nuts.sf %>%
#   mutate(
#     appl_uar = NUTS_ID %in% uar_points.sf_nuts$NUTS_ID,
#     appl_gz = NUTS_ID %in% gzones_sp.sf_nuts$NUTS_ID
#     # min_apl_date = gzones_sp.sf_nuts$min_time
#   ) %>%
#   left_join(min_time) %>%
#   select(-c("FID")) # duplicated

nuts.sf %>% names()
```


## Date of treatment and treatment status

```{r}
nuts.sf.treated <- nuts.sf %>%
  st_join(umweltzonen)

# If there are multiple zones in a given NUTS region I get multiple observations of that region 

nuts.sf.treated <- nuts.sf.treated %>%
  mutate(more_one_nuts = duplicated(NUTS_ID)) %>%
  # Avoid to delete Aachen (it has 2 zones implemented the same year so there is no need to eliminate it)
  filter(!(NUTS_ID == "DEA2D" & more_one_nuts == TRUE)) %>%
  # Avoid to delete Freiburg (it has 2 zones, freiburg is signifficantly bigger and it's applied before so it had not influence from the other one, the other one is deleted)
  filter(!(NUTS_ID == "DE13" & more_one_nuts == TRUE)) %>%
  dplyr::group_by(NUTS_ID) %>%
  dplyr::mutate(more_one_nuts = sum(more_one_nuts)) %>%
  ungroup()

# List of NUTS regions that have only one LEZ: 
nuts.sf.treated %>%
  filter(!is.na(LEZ),
         more_one_nuts == 0) %>%
  # select(NUTS_ID, NUTS_NAME) %>%
  unique()

# Delete those regions that have more than one NUTS
nuts.sf.treated <- nuts.sf.treated %>%
  filter(more_one_nuts == 0) %>%
  select(-more_one_nuts)

# nuts.sf.treated <- nuts.sf.treated %>%
#   group_by(NUTS_ID) %>%
#   mutate(
#     year_stage1 = as_date(Stage_1, format = "%d.%m.%Y") %>% year(),
#     year_stage2 = as_date(Stage_2, format = "%d.%m.%Y") %>% year(),
#     year_stage3 = as_date(Stage_3, format = "%d.%m.%Y") %>% year(),
#     year_announced = as_date(Announcment, format = "%d.%m.%Y") %>% year(),
#   ) %>%
#   ungroup()

nuts.sf.treated %>% head()
```

```{r}
nuts.sf.treated %>%
  # filter(str_detect(NUTS_NAME, "Freiburg")) %>%
  filter(NUTS_ID == "DEA3")
```


## Save the data

```{r}
## st_write(obj = nuts.sf.treated, "data/nuts_sf.shp", 
# delete_layer = TRUE)

# saveRDS(nuts.sf.treated, "data/nuts_sf_treated")
# nuts.sf.treated <- readRDS("data/nuts_sf_treated")
```

## Maps of T and C !

```{r}
temp_treated <- nuts.sf.treated %>%
  filter(treated_uz == TRUE,
         LEVL_CODE == 3)

temp_control <- nuts.sf.treated %>%
  filter(contr_restr_60km == TRUE,
         LEVL_CODE == 3)

treated_and_controls <- leaflet() %>% 
  addTiles() %>%
  addPolygons(data = temp_treated,
              popup = paste0(
                "<b>", temp_treated$NUTS_ID, "</b> <br/>",
                "<b> Nuts name: </b>", 
                temp_treated$NUTS_NAME, "<br/>"),
              weight = 4, col = "red") %>%
  addPolygons(data = lez_shapes, col = "green") %>%
  addPolygons(data = temp_control,
              col = "blue",
              popup = paste0(
                "<b>", temp_control$NUTS_ID, "</b> <br/>",
                "<b> Name: </b>", 
                temp_control$NUTS_NAME, "<br/>")) %>%
  # addMarkers(data = umweltzonen,
  #            popup = paste0(
  #              "<b>", umweltzonen$LEZ, "</b> <br/>",
  #              "<b> Start date: </b>", umweltzonen$Stage_1, "<br/>",
  #              "<b> Announcment date: </b>",
  #              umweltzonen$Announcment, "<br/>",
  #              "<b> Source: </b> Umweltzonen")) %>% 
  setView(15, 50, zoom = 3)

# treated_and_controls

htmlwidgets::saveWidget(treated_and_controls,
                        file="map_tr_and_controls_nomark.html")
```

For NUTS 2

```{r}
temp_treated <- nuts.sf.treated %>%
  filter(treated_uz == TRUE,
         LEVL_CODE == 2) 
  

temp_control <- nuts.sf.treated %>%
  filter(contr_restr_60km == TRUE,
         LEVL_CODE == 2)

treated_and_controls_2 <- leaflet() %>% 
  addTiles() %>%
  addPolygons(data = temp_treated,
              popup = paste0(
                "<b>", temp_treated$NUTS_ID, "</b> <br/>",
                "<b> Start date: </b>", 
                temp_treated$NUTS_NAME, "<br/>"),
              weight = 4, col = "red") %>%
  addPolygons(data = lez_shapes, col = "green") %>%
  addPolygons(data = temp_control, 
              col = "blue",
              popup = paste0(
                "<b>", temp_control$NUTS_ID, "</b> <br/>",
                "<b> Name: </b>", 
                temp_control$NUTS_NAME, "<br/>")
              ) %>%
  addMarkers(data = umweltzonen,
             popup = paste0(
               "<b>", umweltzonen$LEZ, "</b> <br/>",
               "<b> Start date: </b>", umweltzonen$Stage_1, "<br/>",
               "<b> Source: </b> Umweltzonen")) %>% 
  setView(15, 50, zoom = 3)

# treated_and_controls_2

# htmlwidgets::saveWidget(treated_and_controls_2,
#                         file="map_tr_and_controls_n2.html")
```

For NUTS 2 (point)

```{r}
temp_treated <- nuts.sf.treated %>%
  filter(treated_any == TRUE,
         LEVL_CODE == 2)

temp_control <- nuts.sf.treated %>%
  filter(contr_restr_point == TRUE,
         LEVL_CODE == 2)

treated_and_controls_2_point <- leaflet() %>% 
  addTiles() %>%
  addPolygons(data = temp_treated,
              popup = paste0(
                "<b>", temp_treated$NUTS_ID, "</b> <br/>",
                "<b> Start date: </b>", 
                temp_treated$NUTS_NAME, "<br/>"),
              weight = 4, col = "red") %>%
  addPolygons(data = lez_shapes, col = "green") %>%
  addPolygons(data = temp_control, 
              col = "blue",
              popup = paste0(
                "<b>", temp_control$NUTS_ID, "</b> <br/>",
                "<b> Name: </b>", 
                temp_control$NUTS_NAME, "<br/>")
              ) %>%
  addMarkers(data = umweltzonen,
             popup = paste0(
               "<b>", umweltzonen$LEZ, "</b> <br/>",
               "<b> Start date: </b>", umweltzonen$Stage_1, "<br/>",
               "<b> Source: </b> Umweltzonen")) %>% 
  setView(15, 50, zoom = 3)

# treated_and_controls_2_30

htmlwidgets::saveWidget(treated_and_controls_2_point,
                        file="map_tr_and_controls_n2_point.html")
```

end

